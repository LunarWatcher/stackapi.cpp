# Using the library

After installing and linking, using the library is fairly straight-forward:

```cpp
#include "stackapi/StackAPI.hpp"
#include "stackapi/data/structs/comments/Comment.hpp"

#include <iostream>

int main() {
    stackapi::StackAPI api (
        {
            .apiKey{API_KEY}, // How you store your API key before the program launches
                              // is entirely up to you. Hardcoding it is fine, it isn't
                              // considered a secret. 
            .site{"stackoverflow"},
            .pageSize = 2, // Not required, purely for demonstration purposes. pageSize is 100 by default.
            .userAgent{"TODO"}, // Strongly encouraged, see https://stackapps.com/a/8965/69829 and https://meta.stackexchange.com/a/446
        }
    );

    // Make calls to api
}
```

For instance, to retrieve comments, you can use:
```cpp
auto res = api.get<stackapi::Comment>("comments", {
    // Additional URL parameters can go here. Mostly exists for edge-cases with extra GET parameters. This is just a regular map, so arguments are in the form of
    // {"key", "value"}
}, {
    // The second argument is a struct, as revealed by the init syntax. It contains a few common fields, as well as some temporary config override options.
    // For instance, you can write:
    // .site{"metastackoverflow"},
    // to, for this call only, set the site to meta.SO.
    .filter{"!nOedRLmEXx"}, // Not required, but strongly recommended- 
    .pageSize{3}, // again, not required; just for demonstration purposes
});
```

Filters can be generated from [the API documentation](https://api.stackexchange.com/docs) if desired. The library does not currently have any systems in place for generating the filters, as these are generated by the API, and consequently cost API quota to generate automatically. Generating them ahead of time is strongly recommended.

## Global config

The first type passed to the client constructor is a struct called `APIConfig`. The exact definition for the struct is better seen in the source code. 

`APIConfig` contains all the default config variables, as well as data for remaining quota and backoff, if applicable.

## Per-call config

Similarly to the global config, there is a struct called `APIConfigOpt`, that's used for per-API call config.

It primarily contains a few overrides (such as for the auth and site), but also contains a few standard parameters (such as page, pageSize, and filter). This struct is passed as the third parameter to the various API call functions, which are discussed in the next section.

Any parameters supplied to the supported fields in `APIConfigOpt` will override the values `APIConfig`. If they're not present, required values are sourced from the `APIConfig` instance instead.

## GET and POST: an overview

The API client has four different methods spread across two different pairs: `get`, `getRaw`, `post`, and `postRaw`. Both `get` and `post` are wrappers around `getRaw` and `postRaw` respectively, but supplies a generic argument to simplify the JSON deserialisation process. It's three lines of code, so it isn't a big deal, but it's nice to have in my biased opinion.

`getRaw` and `postRaw` return a raw `nlohmann::json` object. While this can be used directly, it's not recommended.

As shown earlier, `get` takes a generic argument, and so does `post`. This type corresponds to a struct that contains the various data attributes associated with a given type. The struct also has a `from_json` method, which is required for the JSON deserialisation process.

There are technically no limits on what type of object can be passed, but default objects for all the types will be provided as the library continues to evolve.

You may also have noticed that there aren't separate functions for different endpoints; this is an intentional design to reduce the amount of code in the library, as well as make it easier to change client-sided if anything changes in the API in the future.

However, this means you're required to keep track of what endpoint to use, and what data type it returns. You can find all this information in the [API documentation](//api.stackexchange.com/docs).

A list of supported data objects can be found by browsing `src/stackapi/data/structs/`.

## NullStruct

NullStruct is a special data object. Unlike all the other objects, it's an empty object that disregards the JSON input it's provided.

In the event that an API endpoint returns an unknown value (or that "practically never returns anything"), or a value you don't care about, you can use `stackapi::NullStruct`. The recommended use-case for this is in the event you want the default API response wrapper from a POST endpoint, and don't want to operate on raw JSON when you do so.

This is also the only type of data structure not formally part of the API spec. It exists because static typing occasionally requires creative solutions. All other data objects line up with the Stack API, as defined in the documentation for v2.3 of the API.

## A note on data object imports

It's strongly recommended that individual objects are imported separately when needed. Note that some imports may be unnecessary if they're dependencies of other structs, but that's not really important. It's effectively import on demand due to being needed by a struct you've imported.

If, however, you have a large amount of different data objects used, and don't want to import them all manually, you can `#include "stackapi/data/structs/ImportAll.hpp"`. This will, as the name suggests, import _all_ data structs currently defined by the library. This can potentially add compiler overhead, so it isn't recommended unless you plan to use a truly large amount of structs, and don't want to import them all separately. YMMV.

## Error handling

The library has a large amount of built-in error handling. This is because Stack has a lot of stupid systems, such as using API-based return values that represent the error rather than HTTP status codes. This itself would be fine, except the API often has problems and returns HTTP code-based errors rather than error codes embedded in returned JSON. 

It's a clusterfuck, and it's annoying to deal with.

There are two primary error handling and error prevention systems: downtime handling, and backoff management. Errors likely to stem from programming errors are thrown as normal, and left as an exercise to the user to either deal with, or disregard and let your favorite service system just restart your bot.

Both of these can be disabled on a per-call or per-instance basis, but are enabled by default, and controlled via `autoHandleBackoff` and `autoHandleDowntime`.

### Downtime handling

Downtime handling mostly consists of retrying until stuff works. This includes both local internet downtime, as well as downtime on Stack's servers.

This is mostly a convenience to avoid complete crashes, and rather resume where you left off when stack and/or your internet comes back, depending on how you prefer to handle these particular errors.

### Backoff handling

Backoff handling, including error handling when backoff has been violated, is automatically handled as well. Backoff is tracked when returned, and a sufficient amount of time is slept on the next API call. Two seconds more than Stack says to back off for is added by default, though this can be controlled via `backoffStrictnessMultiplier` in the config.

Backoff handling can be disabled and manually invoked by either manually checking the backoff period, or by calling `api.checkBackoff()`. 

## Passing additional data

Many endpoints have additional data, and this is a pain to manage. For instance, if you'd like to sort questions by votes, this is sort of manual.

The `GetQuestions` demo has an example for this; sorting by votes. Sorting isn't part of the `opt`s, so you're stuck passing these manually. `GetQuestions` already spoils how this is done, but it's commented out by default:

```cpp
auto res = api.get<stackapi::Question>(
    "questions",
    {
        {"sort", "votes"}
    },
    {
        .filter{"!nOedRLb*BA"},
    });
```

Another related example is editing (**Note:** this requires auth, which is discussed later)
```cpp
api.postRaw(
    "questions/1234/edit",
    {
        {"title", title},
        {"tags", tags},
        ...
    } // Note: opts aren't passed in this case, so it uses the defaults from the global config if necessary
);
```
